# GNOMAN 2.0 License Development Guide

This page documents the end-to-end workflow for issuing and validating offline licenses while developing GNOMAN 2.0.
It references the Python tooling under `backend/licenses/` and the TypeScript services that enforce license checks.

## Repository touchpoints

- **Key generation script:** `backend/licenses/make_keys.py`
- **License issuer:** `backend/licenses/gen_license.py`
- **Backend verifier:** `backend/services/licenseService.ts`
- **Renderer activation UI:** `renderer/src/pages/Settings.tsx`
- **Cached license record:** `.gnoman/license.json`

Review these files before shipping changes so the issuance pipeline stays compatible across the stack.

## Generating a signing keypair

1. Ensure you have Python 3.10+ with `pip` and the `cryptography` library installed:
   ```bash
   pip install cryptography
   ```
2. From `backend/licenses/`, run the key generation helper:
   ```bash
   python make_keys.py
   ```
3. Safeguard the resulting `license_private.pem` (keep offline) and distribute `license_public.pem` with the app.
   The backend expects the public key at `backend/licenses/license_public.pem`.

## Issuing a license token

1. With the desired private key in place, run the issuer script (single-line syntax shown for copy/paste safety):
   ```bash
   python gen_license.py --priv /secure/path/license_private.pem --id customer-identifier --product GNOMAN --version 2.0.0 --days 365
   ```
2. The script prints two formats:
   - `RAW TOKEN`: base64url payload and signature separated by a dot (the backend stores this exact string).
   - `HUMAN-FRIENDLY`: base32 groups that are easier to communicate to customers.
3. Deliver the chosen representation over a secure channel. Never commit issued tokens to the repository.

## Activating and validating locally

1. Start the backend:
   ```bash
   npm run dev:backend
   ```
2. Launch the renderer (or the full Electron shell):
   ```bash
   npm run dev:renderer
   ```
3. Open **Settings â†’ Offline License Activation** and paste either token format. The renderer posts the value to
   `POST /api/license`, which calls `licenseService.applyLicense` for signature verification and expiry checks.
4. Success responses persist the normalized token to `.gnoman/license.json`. Failures surface a toast in the UI and
   print a descriptive error in the backend console.
5. To double-check a token without running the UI, execute the verifier script directly from `backend/licenses/`:
   ```bash
   python verify_license.py license_public.pem "base64url.payload.base64url.signature"
   ```
   The command returns `True` for a valid, non-expired token that matches the expected product/version baked into the
   payload, and `False` otherwise.

## Regression checks

- Run backend unit tests after modifying the verifier:
  ```bash
  npm run test
  ```
- Lint TypeScript/JavaScript code prior to committing:
  ```bash
  npm run lint
  ```
- When touching the Python tooling, add or update sample tokens under `backend/licenses/fixtures/` (create as needed)
  and exercise them manually through the activation UI.

## Troubleshooting tips

- **`Missing license_public.pem`:** Ensure the generated public key file is checked into `backend/licenses/` and rebuilt
  when packaging the app.
- **Invalid signature:** Confirm the private key used for issuance matches the public key bundled with the backend.
- **Expired token:** Adjust the `--days` parameter or issue a new token.
- **Unable to parse token:** Verify spacing. Base32 tokens must retain the grouping generated by `gen_license.py`.
- **Stale cache:** Delete `.gnoman/license.json` to force the backend to revalidate.

## Security best practices

- Store `license_private.pem` in an offline vault and rotate it according to your security policy.
- Use environment-specific keypairs (development, staging, production) to isolate risk.
- Log every issued license in an encrypted tracker that records `id`, `product`, `version`, and expiry.
- Audit backend logs for repeated activation failures, which may indicate tampering attempts.
